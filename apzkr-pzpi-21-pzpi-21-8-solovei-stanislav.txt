Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни “Архітектура програмного забезпечення ”
Тема роботи: Програмна система для управління послугами клінінгових компаній

	Студент гр. ПЗПІ-21-8		________________ Соловей С. Р.
   (підпис)

	Керівник роботи			________________ ст.викл. Сокорчук І.П.
						(підпис)
						   Роботу захищено «__»_________2024 р.
						    з оцінкою__________________________


	Комісія: 			          _________________ доц. Лещинський В.О.
							(підпис)
_________________ доц. Лещинська І.О.
							(підпис)
_________________ ст.викл. Сокорчук І.П.
							(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки     


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	       
Навчальна дисципліна  Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                     Солов’ю Станіславу Романовичу				
1. Тема роботи: 	«Програмна система для управління послугами клінінгових компаній»												
2. Термін узгодження завдання курсової роботи «1»   	квітня      2024 р.
3. Термін здачі студентом закінченої роботи «8»   	червня     2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити:
моніторинг температури та вологості повітря, управління системами запису на послуги з прибирання. Використовувати ОС Windows 10, СУБД MySQL,середовище розробки Microsoft Visual Studio Code
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування
програмного проекту, структура бази даних, кодування програмного
проекту, опис розробленої програмної системи, висновки, перелік посилань,  додатки												         
6. Перелік графічного матеріалу з точним зазначенням обов’язкових креслень
    схема бази даних, діаграма варіантів використання, діаграма розгортання,
інтерфейс головної сторінки.								
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	02.04.2024	Виконано
2	Проектування програмного
проекту	12.04.2024	Виконано
3	Кодування програмного проекту	26.04.2024	Виконано
4	Оформлення пояснювальної
записки	01.06.2024	Виконано
5	Захист курсової роботи		

Дата видачі завдання «1»  квітня   2024 р.

Керівник 				______________ ст.викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-8				_____________ Соловей С.Р.
(підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 71 с., 22 рис., 2 табл., 2 додатки, 8 джерел.
КЛІНІНГ, ДАТЧИКИ, РЕАКТ, NODE.JS, ВОЛОГІСТЬ, ТЕМПЕРАТУРА, АВТОМАТИЗАЦІЯ, МОНІТОРИНГ, УПРАВЛІННЯ ПОСЛУГАМИ, MYSQL.
Об’єктом дослідження є система управління послугами клінінгових компаній. Основна увага приділяється автоматизації та моніторингу процесів клінінгу, що дозволяє підвищити ефективність роботи клінінгових компаній та забезпечити високу якість послуг для клієнтів.
Мета курсового проекту полягає у розробці програмної системи для управління послугами клінінгових компаній, яка забезпечує моніторинг та управління кліматичними умовами під час надання послуг, зокрема параметрами вологості та температури повітря. Система також дозволяє автоматизувати робочі процеси, вести облік клієнтів та оптимізувати розподіл ресурсів.
Методи розробки базуються на використанні мови програмування TypeScript у поєднанні з фреймворками React для клієнтської частини та Node.js з Express.js для серверної частини. В якості бази даних обрана MySQL, яка забезпечує надійне зберігання даних та швидкий доступ до них. Інтеграція з датчиками вологості та температури забезпечується через спеціальні API, що дозволяє контролювати умови виконання клінінгових послуг.

За результатами роботи було створено комплексну програмну систему, яка складається з клієнтської частини, серверної частини та інтеграції з датчиками. Система надає інструменти для ефективного управління послугами клінінгових компаній, що сприяє покращенню якості обслуговування клієнтів та оптимізації робочих процесів.
 
ЗМІСТ


Вступ……………………………………………………………………………...8
1 Аналіз предметної області…………………………………………………….9
   1.1 Бізнес-вимоги………………………………………………………………9
      1.1.1 Бізнес-можливості……………………………………………………..9
      1.1.2 Бізнес-цілі та критерії успіху…………………………………………9
      1.1.3 Потреби клієнта або ринку……………………………………………10
      1.1.4 Бізнес-ризики…………………………………………………………..11
   1.2 Бачення рішення…………………………………………………………...12
      1.2.1 Окреслення концепції…………………………………………………12
      1.2.2 Головна функціональність…………………………………………….13
      1.2.3 Припущення і залежності……………………………………………..13
   1.3 Сфера застосування та обмеження……………………………………….14
      1.3.1 Рамки первинного випуску……………………………………………14
      1.3.2 Рамки наступних випусків…………………………………………….15
      1.3.3 Обмеження та винятки………………………………………………...16
   1.4 Бізнес-контекст…………………………………………………………….16
      1.4.1 Профілі зацікавлених сторін………………………………………….16     
      1.4.2 Пріоритети проекту……………………………………………………17
      1.4.3 Операційне середовище……………………………………………….18
2 Архітектура програмної системи …………………………………………….19
   2.1 Архітектура серверної частини…………………………………………...19
   2.2 Архітектура IoT частини…………………………………………………..23
3 Структура бази даних…………………………………………………………25
4 Опис програмної системи……………………………………………………..43
   4.1 Виклик і завантаження…………………………………………………….27
   4.2 Призначення і логічна структура…………………………………………27
   4.3 Опис програмної реалізації……………………………………………….28
Висновки…………………………………………………………………………34
Перелік джерел посилань……………………………………………………….35
Додаток А Результат перевірки на плагіат…………………………………….36
Додаток Б Код серверної частини………………………………………………37
Додаток В Код клієнтської частини..…………………………………………..46 
ВСТУП


	У сучасному світі попит на послуги клінінгових компаній постійно зростає, а отже є потреба в автоматизації більшості процесів та забезпечення кращої ефективності, якості обслуговування клієнтів. Розробка програмної системи для управління послугами клінінгових компаній має на меті спростити та пришвидшити усі пов’язані з цим процеси, а саме: зручне планування та організації часу, широкий вибір послуг, тощо.
	Підвищення ефективності процесів має вагомий внесок у конкурентоспроможності клінінгових компаній та їх здатність задовольнити потреби клієнтів. Системи автоматизації допомагають зменшити навантаження на співробітників, знизити ймовірність помилок та забезпечити своєчасне виконання замовлень. Розробка такої системи дозволяє керувати усіма аспектами обслуговування клієнтів, від їх реєстрації до планування і контролю якості виконання замовлень.
Сучасні технології автоматизації дозволяють також зменшити витрати, підвищити ефективність роботи та поліпшити взаємодію з клієнтами. Впровадження програмної системи забезпечить оптимізацію процесів, що призводить до поліпшення якості послуг, покращення комунікації з клієнтами, створення сприятливого середовища для введення бізнесу.
Застосування автоматизованих систем у клінінговій сфері є важливим кроком до створення більш ефективного та зручного сервісу для користувачів, що у свою чергу вплине на зростання задоволеності клієнтів і довгостроковий успіх компаній у цій галузі.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес- вимоги
1.1.1 Бізнес-можлливості


Розробка програмної системи з управління послугами клінінгових компаній забезпечить ефективне адміністрування процесів, моніторинг виконання послуг, ефективно управляти послугами та підтримувати високий рівень обслуговування клієнтів.  Система забезпечує точний контроль над процесами авторизації та реєстрації клієнтів, дозволяє їм швидко обирати та планувати прибирання заздалегідь послуги, а також координувати дату та час виконання робіт. Це призводить до оптимізації витрат, зменшення помилок, підвищення ефективності та якості обслуговування клієнтів. Програмна система відповідає найвищим технічним вимогам, забезпечуючи масштабованість, безпеку даних, швидкодію та надійність. Також система здатна інтегруватись з іншими інформаційними системами моніторингу, безпеки, тощо, для ще більшої ефективності. 
Програмна система з управління послугами клінінгових компаній має численні переваги серед інших найвідоміших конкурентів на ринку, такими як: «Уберем.», «CLEAN-HOME», та інші. Серед основних переваг нашої програмної системи є більш розширені можливості для інтеграції з іншими інформаційними системами, адаптивне управління послугами, автоматичне відстеження та контроль виконання якості послуг, що робить її більш ефективною та гнучкою у використанні.

1.1.2 Бізнес-цілі та критерії успіху


БЦ-1: Забезпечити власникам та адміністрації клінінгових компаній доступ до актуальної та надійної інформації щодо їх клієнтів, обраних послуг та безпеки даних.
	БЦ-2: Створити конкурентну перевагу на ринку клінінгових послуг, використовуючи усі найновіші технології та IoT застосунок, щоб забезпечити оптимальні умови для адміністрування бізнес процесів.
	БЦ-3: Розширити географію діяльності, пропонуючи програмну систему не лише в Україні, а й в інших країнах за кордоном, для цього забезпечити локалізацію не лише українською мовою, а й англійською.
	БЦ-4: Залучити нових клієнтів та партнерів шляхом впровадження гнучких тарифних планів і високого рівня сервісу.
КУ-1: Набрати не менше 100 клінінгових компаній як активних користувачів системи протягом першого року роботи.
КУ-2: Збільшити ефективність управління замовленнями на 20% протягом перших 12 місяців впровадження системи.
КУ-3: Зменшити витрати на адміністративні процеси на 15% протягом першого року впровадження системи.
КУ-4: Забезпечити задоволеність не менше 95% клієнтів з обслуговуванням та якістю наданих послуг.
КУ-5: Отримати позитивний відгук не менше ніж від 80% клієнтів щодо якості управління послугами.
КУ-6: Досягти позитивного фінансового результату в кінці другого року роботи, покривши всі витрати на розробку, запуск та підтримку системи.
КУ-7: Розширити впровадження системи ще в трьох країнах протягом третього року роботи.
КУ-8: Стати лідером на ринку програмних рішень для клінінгових компаній в Україні та серед провідних гравців у світі до п’ятого року роботи.


1.1.3 Потреби клієнта або ринку


Автоматизація процесів управління замовленнями: 
- Клінінгові компанії потребують системи, яка може автоматично обробляти запити, планувати послуги та управляти їх виконанням.
Гнучкість у виборі послуг: 
- Клієнти очікують можливість легко обирати потрібні послуги і налаштовувати їх відповідно до своїх потреб.
Адміністрування послуг:
- Власники або адміністрація клінінгових компаній очікують на легке адміністрування (додавання/видалення даних) користувачів, послуг, матеріалів, які були задійснені під час прибирання.
Ефективне планування і організація: 
- Користувачі вимагають систему, яка дозволяє зручно планувати і організовувати час виконання послуг.
Моніторинг та звітність: 
- Система повинна забезпечувати можливість моніторингу стану замовлень і генерації звітів для прийняття обґрунтованих рішень.
Інтеграція з іншими системами: 
- Клієнти очікують, що система буде інтегрована з наявними інструментами для забезпечення комплексного підходу до управління послугами.


1.1.4 Бізнес-ризики


Конкуренція на ринку: 
- Ринок клінінгових послуг є висококонкурентним і включає як великі компанії, так і компанії-початківці. Це може ускладнити залучення нових клієнтів та утримання існуючих. Щоб залишатися конкурентоспроможними, необхідно постійно вдосконалювати продукти та маркетингові стратегії.
Невідповідність вимогам користувачів: 
- Нерозуміння потреб користувачів призводить до незадоволення клієнтів і збільшення витрат на виправлення помилок. Регулярний зворотній зв'язок та адаптація системи є ключем до успішного впровадження.
Обмеженість інвестицій: 
- Брак фінансових ресурсів може затримати розробку та підтримку системи. Слід шукати додаткові джерела фінансування та ефективно використовувати наявні ресурси.
Ризик затримки розробки: 
- Технічні проблеми та труднощі з інтеграцією можуть затримати реалізацію проекту.
- Правовий ризик: 
- Важливо забезпечити відповідність системи всім законодавчим вимогам, щоб уникнути штрафів або заборон у певних сферах.
Ризик безпеки даних: 
- Забезпечення високого рівня захисту конфіденційної інформації має вирішальне значення для збереження довіри клієнтів і запобігання потенційним витокам даних.


1.2 Бачення рішення
1.2.1 Окреслення концепції


Цей продукт надає клінінговим компаніям ефективний інструмент для управління своїми послугами і є ключем до оптимізації процесу надання послуг та підвищення рівня задоволеності клієнтів. Впровадивши програмний комплекс для управління послугами клінінгової компанії, менеджери можуть легко організовувати замовлення, планувати прибирання та контролювати виконання завдань в режимі реального часу. Основними перевагами цього продукту є зниження адміністративних витрат, покращення обслуговування клієнтів та прозорість процесів.
Система автоматизує такі процеси, як вибір послуг, розподіл завдань між працівниками та управління замовленнями і платежами. Це зменшує кількість людських помилок і гарантує, що замовлення виконуються безперебійно і вчасно. Впровадження програмного комплексу сприяє підвищенню ефективності роботи клінінгових компаній завдяки своєчасній обробці замовлень та підвищенню лояльності клієнтів. Крім того, система дає компаніям можливість стати більш конкурентоспроможними і надавати клієнтам високоякісні послуги за рахунок оптимізації своїх операцій.
Програмні комплекси для управління послугами клінінгових компаній - це інноваційні рішення, які допомагають оптимізувати процеси обслуговування, підвищити продуктивність персоналу і поліпшити якість послуг, що надаються.


1.2.2 Головна функціональність


MF-1: Керування замовленнями та графіками прибирання.
MF-2: Моніторинг температури та вологості у реальному часі.
MF-3: Сповіщення клієнтів і співробітників про статус замовлення.
MF-4: Моніторинг завдань в режимі реального часу.
MF-5: Управління базою даних клієнтів.
MF-6: Друк чеку з основною інформацією після замовлення послуги.
MF-7: Інтеграція з календарем для планування роботи.
MF-8: Автоматичне резервне копіювання даних.
MF-9: Шифрування даних для безпеки.
MF-10: Аудит та реєстрація доступу.
MF-11: Персоналізовані пропозиції для клієнтів.
MF-12: Управління правами доступу для різних рівнів користувачів.
MF-13: Аналіз і звітність про роботу.
MF-14: Багатомовна підтримка інтерфейсу користувача.
MF-16: Автоматичне оновлення програмного забезпечення.


1.2.3 Припущення і залежності


Залежність №1: Продукт є корисним та затребуваним для клінінгових компаній різного розміру, які прагнуть підвищити операційну ефективність.
Залежність №2: Продукт буде мати унікальну назву (CleanMasterSolutions), щоб клієнти могли легко знайти його на ринку.
Залежність №3: Продукт працюватиме лише за наявності стабільного інтернет-з'єднання.
Залежність №4: Швидкість оновлення інформації в системі залежить від якості серверного обладнання та інфраструктури.
Залежність №5: Успішне впровадження системи залежить від наявності необхідного апаратного та програмного забезпечення у замовника.
Залежність №6: Розробка системи може вимагати співпраці з партнерами, такими як платіжні системи та постачальники програмного забезпечення.
Припущення №1: Для роботи системи необхідний сучасний пристрій (комп'ютер, планшет або смартфон) з підтримкою веб-браузера.
Припущення №2: Для роботи продукту необхідна стабільна інфраструктура, яка гарантує його працездатність.
Припущення №3: Система буде цікава не тільки великим клінінговим компаніям, але й малому та середньому бізнесу.
Припущення №4: Продукт повинен бути достатньо гнучким, щоб відповідати різним потребам компаній.
Припущення №5: Користувачі мають базові технічні навички для роботи з програмним забезпеченням.
Припущення 6: Система не потребує значних змін і може бути легко інтегрована з існуючими системами підприємства.

1.3 Сфера застосування та обмеження.
1.3.1 Рамки первинного випуску


Функціонал серверної частини:
- Управління базою даних клієнтів та замовлень.
- Автоматизація розподілу завдань між співробітниками.
- Формування звітів та аналітики.
- Інтеграція з платіжними системами.
- Резервне копіювання та шифрування даних.
- Захист персональних даних відповідно до стандартів безпеки (GDPR).
- Управління правами доступу та ролями користувачів.
  - Логіка автоматизації для управління процесами
	Функціонал клієнтської частини:
- Інтерактивна панель управління для менеджерів і співробітників
- Відображення даних про замовлення та статус виконання в режимі реального часу
- Налаштування системи під потреби користувача
- Багатомовна підтримка інтерфейсу
- Реєстрація та авторизація користувачів
- Інтеграція з календарем для планування роботи

Функції мобільного додатку:
- Push-повідомлення про статус замовлення
- Доступ до даних про замовлення в режимі реального часу.
- Керування налаштуваннями з мобільного пристрою.


1.3.2 Рамки наступних випусків


Функціонал мобільного застосунку:
- Розширені сповіщення та тривоги.
- Доступ до технічної підтримки з мобільного додатку.
	Функціонал клієнтської частини:
- Можливість обміну відгуками та коментарями між користувачами.
- Використання машинного навчання для оптимізації розподілу завдань.
- Реалізація голосового управління.
- Додаткові можливості інтеграції з іншими системами управління.
Функціонал серверної частини:
- Інтеграція з іншими платіжними та інформаційними системами


1.3.3 Обмеження та винятки


- Ефективна робота системи вимагає стабільного інтернет-з'єднання.
- Інтерфейс користувача спочатку надається тільки українською мовою.
- Доступ до даних системи надається тільки авторизованим користувачам з відповідними правами доступу.
- Система оптимально працює на сучасному обладнанні. Старіші моделі можуть потребувати додаткового налаштування.


	1.4 Бізнес-контекст
	1.4.1 Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Адміністрація клінінгових компаній	Ефективне управління послугами, збільшення прибутку	Зацікавлені у покращенні операційної ефективності та якості послуг	Оптимізація процесів, підвищення задоволеності клієнтів	Бюджетні обмеження, необхідність інтеграції з наявними системами
Персонал клінінгових компаній	Зручність планування робочого часу	Зацікавлені у зручному інтерфейсі та можливостях швидкого доступу до інформації	Легке планування та управління завданнями, мінімізація помилок	Навчання для роботи з новою системою, адаптація до змін
Клієнти клінінгових компаній	Якість та своєчасність послуг	Зацікавленні у зручності замовлення та відстеження послуг	Можливість швидкого замовлення та моніторингу процесу	Інформаційна прозорість, конфіденційність даних
Розробник проекту	Реалізація технологічного рішення, прибуток	Сильно зацікавлені у розробці та підтримці системи	Репутація, фінансовий успіх	Технічні виклики, вимоги замовника


	1.4.2 Пріоритети проекту


Таблиця 1.2 – Пріоритети проекту
Показник	Виконання	Обмеження	Ступінь свободи
План робіт	Початковий випуск має бути доступний 08.06.2024		
Функціональність		Всі можливості заплановано на випуск 1.0 повинні бути повністю працездатними	Не менше 80% від високопріоритетних функцій повинно бути включено в початковий випуск
Якість			Перевірка на можливі баги/помилки повинні оброблені та виконані
Персонал		Максимальний розмір команди це 1 розробник та адміністратор	
Ціна		Безкоштовно	


	1.4.3 Операційне середовище


Даний продукт буде використовуватися через браузер на комп’ютері або за допомогою телефону чи планшету. Для використання мобільного додатку має використовуватися система Android 12 та вище або iOS 15 та вище. Система використовує СУБД MySQL для забезпечення ефективного зберігання та обробки даних. Серверна частина розробляється на мові JavaScript з використанням Node.js та Express.js, а клієнтська частина використовує React.js та Typescript. Для розробки мобільного застосунку буде використовуватися React Native. Цей стек технологій дозволяє побудувати продукт, який є легко масштабованим, розширюваним та підтримуваним. Завдяки ретельному вибору технологій і використанню готових бібліотек для інтеграції сторонніх сервісів, система може швидко вийти на ринок та взаємодіяти з іншими платформами.
 
2 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
	2.1 Архітектура серверної частини


Архітектура серверної частини розроблена з урахуванням різних ролей, що беруть участь у взаємодії з нею: Користувач, Адміністратор Замовлень та Адміністратор Баз Даних. Кожна роль виконує свої унікальні дії, спрямовані на оптимальне використання системних можливостей.
Користувачі можуть виконувати такі дії, як реєстрація та авторизація, перегляд доступних клінінгових послуг, вибір конкретних послуг, оформлення замовлень, а також управління своїми особистими даними. Ці функції забезпечують зручний доступ до необхідних сервісів та покращують взаємодію з системою.
Адміністратор Замовлень відповідає за управління замовленнями та клієнтами, зокрема налаштування статусів замовлень, призначення виконавців, моніторинг виконання робіт, а також управління розкладом клінінгових послуг. Це забезпечує контроль за процесом надання послуг, а також ефективне управління ресурсами компанії.
Адміністратор Баз Даних займається адмініструванням баз даних, здійснює резервне копіювання, забезпечує безпеку та цілісність даних, а також оптимізацію баз даних для підвищення продуктивності системи. Це гарантує збереження важливої інформації та забезпечує безперебійну роботу системи.
Архітектура забезпечує чіткий розподіл функцій між різними ролями, що сприяє підвищенню продуктивності та безпеки системи, а також полегшує її подальший розвиток та підтримку.
 


Серверна частина системи була розроблена за технологією Node.js та Express.js, використовуючи мову програмування JavaScript з TypeScript. Система використовує реляційну базу даних MySQL для зберігання даних про послуги клінінгових компаній, користувачів, а також інших системних та адміністративних даних. Компоненти бази даних забезпечують високий рівень надійності та швидкодії доступу до інформації. База даних інтегрується з серверною частиною через офіційний драйвер MySQL для Node.js, що забезпечує ефективну роботу з даними. 
Хешування паролів користувачів здійснюється за допомогою криптографічних хеш-функцій, таких як bcrypt, що забезпечує високий рівень безпеки збережених даних.
Серверна частина складається з трьох основних компонентів: User-Interface, Web Server, та Database Server. Всі компоненти пов'язані між собою через захищений протокол HTTPS, що гарантує конфіденційність даних під час передачі.
Node.js і Express.js використовують маршрутизатор для управління HTTP-запитами, де URL-шляхи визначають, які контролери або маршрути повинні обробляти запит. Система також використовує Middlewares для попередньої обробки запитів, що дозволяє налаштовувати функції аутентифікації, логування, та обробки помилок.

 


Ключові кроки користувача під час взаємодії з системою тісно пов'язані з функціональністю серверної частини.
Процес починається з переходу користувача на сторінку авторизації, де він вводить свій логін і пароль. Серверна частина перевіряє введені дані, здійснюючи аутентифікацію користувача. Якщо логін або пароль невірні, сервер повертає користувача на сторінку авторизації з відповідним повідомленням про помилку.
Після успішної авторизації сервер надає користувачу доступ до основних функцій системи. Однією з ключових функцій є можливість перегляду доступних клінінгових послуг та вибору потрібної. Це включає взаємодію з базою даних MySQL, де зберігаються всі дані про послуги, компанії, графіки та ціни. Сервер обробляє запити користувача та надає актуальну інформацію про наявність та умови надання послуг.
Користувач також може отримувати додаткові рекомендації щодо вибору послуг на основі їхніх попередніх замовлень та рейтингу компаній. Ці рекомендації генеруються сервером на основі аналізу даних про попередні взаємодії та встановлених критеріїв.
Наприкінці сесії користувач може вибрати опцію виходу з облікового запису. Сервер обробляє запит на вихід, завершує активну сесію та забезпечує безпеку облікових даних, видаляючи всі тимчасові файли та дані сеансу.

 



	2.2 Архітектура IoT частини


	Архітектура IoT частини системи управління послугами клінінгових компаній включає використання мікроконтролера ESP32 та двох датчиків: датчика вологості та датчика температури повітря. Кожен з цих датчиків виконує свою специфічну функцію, забезпечуючи збір важливих даних про стан приміщень, де проводиться клінінг.
Датчик вологості використовується для вимірювання рівня вологості у приміщенні. Він передає дані на мікроконтролер ESP32 з високою точністю, що дозволяє контролювати і коригувати рівень вологості під час та після клінінгових робіт. Це важливо для запобігання пошкодженням, спричиненим підвищеною вологістю, наприклад, у дерев'яних або чутливих до вологи матеріалах.
Датчик температури повітря вимірює температуру у приміщенні, де проводиться клінінг. Аналогічно до датчика вологості, він передає аналогові сигнали на ESP32, який перетворює їх у цифрові значення для подальшої обробки та передачі. Дані про температуру можуть бути використані для забезпечення оптимальних умов для проведення клінінгових робіт, таких як сушка або обробка поверхонь.
Мікроконтролер ESP32 виконує роль центрального вузла, який збирає дані з обох датчиків. Кожні 10 секунд ESP32 зчитує показники з датчиків і надсилає ці дані на сервер за допомогою HTTP-запиту. Після кожного успішного запиту ESP32 отримує статус підтвердження про запис даних, який відображається в консолі ESP32 для моніторингу. Це дозволяє контролювати умови в реальному часі і вчасно реагувати на зміну параметрів середовища.
Сервер обробляє отримані дані та записує їх до бази даних MySQL. Зберігання історичних даних дозволяє проводити аналіз і прогнозування, що в свою чергу допомагає оптимізувати процеси клінінгу та забезпечити їх високу ефективність. 
Ця архітектура забезпечує зручність та точність в управлінні умовами клінінгових робіт, що робить систему надійним інструментом для клінінгових компаній.



 
3 СТРУКТУРА БАЗИ ДАНИХ


	Для розробки програмного продукту, що займається управлінням послугами клінінгових компаній, була використана реляційна база даних MySQL. Використання реляційної моделі даних дозволяє організувати зберігання структурованої інформації у вигляді таблиць, забезпечуючи цілісність даних і підтримку складних запитів. MySQL забезпечує високу продуктивність та надійність, що є критично важливими для обробки великих обсягів даних, пов'язаних з управлінням замовленнями, клієнтами, графіками та іншою операційною інформацією в реальному часі.
Крім того, MySQL добре підходить для обробки структурованих даних і підтримує високу швидкість зчитування та запису. Це робить її ідеальною для використання у системах, що вимагають стабільної роботи з великими обсягами інформації, таких як система управління послугами клінінгових компаній. Завдяки реляційній природі MySQL, можливо легко реалізувати складні запити для аналітики та звітності, що дозволяє ефективно управляти бізнес-процесами та приймати обґрунтовані рішення. Було створено наступні таблиці в базі даних:
	- User (таблиця з інформацією щодо користувачів). Містить в собі наступні поля: id, login, password, phone_number, first_name, is_admin.
	- Service (таблиця з інформацією щодо послуг, які надає клінінгова компанія). Містить наступні поля: id, name, description, price.
	- Cleaning (таблиця з інформацією про запис на послугу). Ця таблиця створена, щоб зв’язати таблиці User та Service зв’язком багато-до багатьох. Містить наступні поля: id, date, time, description, user_id, service_id.
	- Material (таблиця з інформацією про матеріали на складі). Має наступні поля: id, name, quantity, service_id.
	- Feedback (таблиця з інформацією про відгуки користувачів). Містить наступні поля: id, description, rating, service_id.

 

 
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
	4.1 Виклик і завантаження


Для того, щоб запустити програму з управління послугами клінінгових компаній, спочатку необхідно завантажити всі вихідні файли проєкту. Для коректної роботи з програмою потрібно мати встановлений Node.js, npm для управління залежностями, а також MySQL як систему управління базами даних.
Спочатку користувач повинен налаштувати базу даних MySQL, створивши необхідні таблиці та завантаживши дані. Після цього слід встановити всі залежності проєкту, виконавши команду «npm install», яка автоматично завантажить і встановить усі необхідні пакети.
Далі користувач повинен запустити серверну частину програми, яка написана на Node.js з використанням фреймворку Express.js. Для цього потрібно виконати команду «npm start», яка запустить сервер і підключить його до бази даних MySQL. Після успішного запуску серверної частини, користувач зможе отримати доступ до клієнтської частини програми, яка також буде запущена командою «npm start».
Після виконання цих кроків користувач побачить інтерфейс системи і зможе працювати з програмою, використовуючи всі її можливості для управління послугами клінінгових компаній.


	4.2 Призначення і логічна структура
Ця система призначена для ефективного управління послугами клінінгових компаній. Вона складається з наступних модулів:
- Модуль "Клієнти": Цей модуль дозволяє керувати даними про клієнтів, включаючи імена, контактні дані, історію замовлень та відгуки. Завдяки цьому модулю можна централізовано зберігати і отримувати доступ до всієї необхідної інформації про клієнтів, що взаємодіють з клінінговими компаніями.
- Модуль "Замовлення": Даний модуль відповідає за створення та управління замовленнями на послуги клінінгу. Він дозволяє відстежувати статуси замовлень, призначати виконавців, а також забезпечує зручний інтерфейс для оформлення нових замовлень з можливістю вибору послуг та графіку їх виконання.
- Модуль "Персонал": Цей модуль включає управління даними про працівників клінінгових компаній, зокрема їхні імена, графіки роботи, кваліфікацію та спеціалізацію. Він дозволяє централізовано координувати роботу персоналу та призначати відповідальних за виконання конкретних замовлень.
- Модуль "Обладнання": Модуль забезпечує управління та облік обладнання, яке використовується під час надання клінінгових послуг. Кожен елемент обладнання має унікальний ідентифікатор, статус, місцезнаходження та історію обслуговування. Це дозволяє контролювати стан та готовність обладнання до використання.
- Модуль "Дані з датчиків": Цей модуль відповідає за збір та обробку даних з датчиків, що вимірюють температуру та вологість повітря у приміщеннях, де надаються клінінгові послуги. Дані дозволяють контролювати умови навколишнього середовища під час виконання робіт, що може впливати на якість надання послуг.
- Модуль "Аналітика та звітність": Даний модуль генерує звіти та надає аналітичну інформацію про ефективність роботи клінінгової компанії. Він дозволяє аналізувати дані про замовлення, якість обслуговування, задоволеність клієнтів та ефективність використання ресурсів.
- Модуль "Сповіщення": Модуль забезпечує надсилання сповіщень у випадку, якщо певні умови виконання замовлення, такі як рівень вологості або температура повітря, відхиляються від встановлених параметрів. Це допомагає оперативно реагувати на зміни умов та забезпечувати якісне виконання клінінгових послуг.


	4.3 Опис програмної реалізації


	При запуску програмної системи користувача зустрічає головна сторінка програмної системи, де він одразу має змогу зареєструватися/увійти та замовити послугу.

 


	З навігаційного меню користувач одразу має змогу пройти етап реєстрації/авторизації.

 

	Поля для вводу інформації сигналізують візуально користувача про правильність введення даних. Всі перевірки, щодо правильність введених даних відбуваються на клієнтській частині.

 


 

	Також користувач може змінити мову у будь-який час. За замочуванням мова програмної системи – англійська. Також для користувачів, у яких є права доступу до адміністрування всіх процесів, з’явиться «Admin Panel.

 


 

Розглянемо функціонал адміністрування (перегляд, додавання, видалення даних).

 


 

	Після реєстрації/авторизації користувач має змогу замовити будь-яку послугу прибирання серед доданих раніше через меню адміністрування власником чи адміністратором клінінгової компанії.

 


	Після запису на послугу користувач обов’язково отримує електронний чек з усією необхідною інформацією.

 


 
ВИСНОВКИ


Під час виконання курсового проекту було створено програмну систему для управління послугами клінінгових компаній[8]. Процес розробки включав аналіз предметної області, розробку архітектури системи, створення бази даних, а також опис функціональності програмної системи.
Система розроблена з використанням сучасних технологій і підходів. Клієнтська частина системи розроблена на основі React.js з використанням TypeScript, що забезпечує динамічний і зручний інтерфейс для користувачів. Серверна частина реалізована за допомогою Node.js і Express.js, що дозволяє ефективно обробляти запити та взаємодіяти з базою даних MySQL для зберігання та управління даними.
Система інтегрується з датчиками температури та вологості повітря, що дає змогу контролювати умови, в яких надаються клінінгові послуги. Завдяки цьому клієнти можуть бути впевнені, що робота виконується в оптимальних умовах.
Запроваджена система дозволяє здійснювати ефективне управління послугами клінінгу[8], забезпечуючи зручність для користувачів і оптимізацію ресурсів компаній. Система забезпечує автоматичний збір даних, їх обробку та відображення результатів у режимі реального часу. Це дозволяє клінінговим компаніям підвищити якість наданих послуг, а також поліпшити взаємодію з клієнтами.
Обрані технології дозволяють побудувати продукт, який легко масштабується, розширюється та підтримується. Завдяки цьому система може швидко адаптуватися до змінних вимог ринку та інтегруватися з іншими платформами.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАНЬ


1. Документація Javascript. URL: https://www.w3schools.com/js/DEFAULT.asp (дата звернення: 13.03.2024).
2. Документація React-Bootstrap. URL: https://react-bootstrap.github.io/docs/getting-started/introduction (дата звернення: 13.04.2024).
3. Документація React. URL: https://reactjs.org (дата звернення: 16.05.2023).
4. Документація симулятора Wokwi IoT. URL: https://docs.wokwi.com (дата звернення: 03.05.2024).
5. Документація API RESTful. URL: https://restfulapi.net (дата звернення: 13.04.2024).
6. Еріх Гамма, Річард Хелм, Ральф Джонсон, Джон Вліссідес. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley Professional, 1994. – 395 с.
7. Посилання на Github репозиторій. URL: https://github.com/NureSoloveiStanislav/apzkr-pzpi-21-8-solovei-stanislav
8. Посилання на функціональне тестування системи URL: https://youtu.be/SrYr4J2_iOk (дата звернення: 17.06.2024).
 
ДОДАТОК А
Результат перевірки на плагіат
 
ДОДАТОК Б
Код серверної частини


Код головного файлу server.js
1	const connection = require('./mysql/mysql');
2	const express = require('express');
3	const session = require('express-session');
4	const cors = require('cors');

5	const userManager = require("./classes/UserManager/UserManager");
6	const bcrypt = require("bcrypt");

7	const app = express();
8	const router = express.Router();

9	const corsOptions = {
10	origin: 'http://localhost:3000',
11	methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
12	credentials: true,
13	optionsSuccessStatus: 204,
14	};

15	app.use(session({
16	secret: 'stanislav',
17	resave: false,
18	saveUninitialized: true,
19	cookie: {maxAge: 10 * 60 * 1000}
20	}));
21	app.use(cors(corsOptions));
22	app.use(express.json());
23	app.use(express.urlencoded({extended: true}));

24	const PORT = 5000;

25	app.get('/api/v1/users', async (req, res) => {
26	try {
27	const sql = 'SELECT * FROM user';

28	connection.query(sql, (err, results) => {
a.	if (err) {
b.	console.error('Error fetching users data: ', err);
c.	res.status(500).send('Internal Server Error');
d.	} else {
e.	res.status(200).json(results);
f.	}
29	});
30	} catch (e) {
31	console.error(e);
32	}
33	});

34	app.get('/api/v1/materials', async (req, res) => {
35	try {
36	const sql = 'SELECT * FROM material';

37	connection.query(sql, (err, results) => {
a.	if (err) {
b.	console.error('Error fetching materials data: ', err);
c.	res.status(500).send('Internal Server Error');
d.	} else {
e.	res.status(200).json(results);
f.	}
38	});
39	} catch (e) {
40	console.error(e);
41	}
42	});

43	app.post('/api/v1/materials', async (req, res) => {
44	const {name, quantity, service_id} = req.body;

45	try {
46	const sql = 'INSERT INTO material (name, quantity, service_id) VALUES (?, ?, ?)';
47	const values = [name, quantity, service_id];

48	connection.query(sql, values, (err, result) => {
a.	if (err) {
b.	console.error('Error inserting data into the database: ', err);
c.	} else {
d.	console.log('Data inserted successfully');
e.	}
49	});
50	} catch (e) {
51	console.error('Error: ', e);
52	}

53	res.status(200).send('Material added successfully');
54	});

55	app.delete('/api/v1/materials/:materialId', (req, res) => {
56	const materialId = req.params.materialId;

57	const sql = 'DELETE FROM material WHERE id = ?';
58	connection.query(sql, [materialId], (err, result) => {
59	if (err) {
a.	console.error('Error deleting service: ', err);
b.	res.status(500).send('Internal Server Error');
60	} else {
a.	if (result.affectedRows > 0) {
b.	res.status(200).send('Service deleted successfully');
c.	} else {
d.	res.status(404).send('Service not found');
e.	}
61	}
62	});
63	});

64	app.get('/api/v1/services', async (req, res) => {
65	try {
66	const sql = 'SELECT * FROM service';

67	connection.query(sql, (err, results) => {
a.	if (err) {
b.	console.error('Error fetching services data: ', err);
c.	res.status(500).send('Internal Server Error');
d.	} else {
e.	res.status(200).json(results);
f.	}
68	});
69	} catch (e) {
70	console.error(e);
71	}
72	});

73	app.post('/api/v1/services', async (req, res) => {
74	const {name, description, price} = req.body;

75	try {
76	const sql = 'INSERT INTO service (name, description, price) VALUES (?, ?, ?)';
77	const values = [name, description, price];

78	connection.query(sql, values, (err, result) => {
a.	if (err) {
b.	console.error('Error inserting data into the database: ', err);
c.	} else {
d.	console.log('Data inserted successfully');
e.	}
79	});
80	} catch (e) {
81	console.error('Error: ', e);
82	}

83	res.status(200).send('Service added successfully');
84	});

85	app.delete('/api/v1/services/:serviceId', (req, res) => {
86	const serviceId = req.params.serviceId;

87	const sql = 'DELETE FROM service WHERE id = ?';
88	connection.query(sql, [serviceId], (err, result) => {
89	if (err) {
a.	console.error('Error deleting service: ', err);
b.	res.status(500).send('Internal Server Error');
90	} else {
a.	if (result.affectedRows > 0) {
b.	res.status(200).send('Service deleted successfully');
c.	} else {
d.	res.status(404).send('Service not found');
e.	}
91	}
92	});
93	});

94	app.get('/api/v1/cleaning', async (req, res) => {
95	try {
96	const sql = 'SELECT * FROM cleaning';

97	connection.query(sql, (err, results) => {
a.	if (err) {
b.	console.error('Error fetching services data: ', err);
c.	res.status(500).send('Internal Server Error');
d.	} else {
e.	res.status(200).json(results);
f.	}
98	});
99	} catch (e) {
100	console.error(e);
101	}
102	});

103	app.post('/api/v1/cleaning', async (req, res) => {
104	const {
105	date,
106	time,
107	description,
108	user_id,
109	service_id
110	} = req.body;

111	try {
112	const sql = 'INSERT INTO cleaning (date, time, description, user_id, service_id) VALUES (?, ?, ?, ?, ?)';
113	const values = [date, time, description, user_id, service_id];

114	connection.query(sql, values, (err, result) => {
a.	if (err) {
b.	console.error('Error inserting data into the database: ', err);
c.	} else {
d.	console.log('Data inserted successfully');
e.	}
115	});
116	} catch (e) {
117	console.error('Error: ', e);
118	}

119	res.status(200).send('Service added successfully');
120	});

121	app.delete('/api/v1/cleaning/:cleaningId', (req, res) => {
122	const cleaningId = req.params.cleaningId;

123	const sql = 'DELETE FROM cleaning WHERE id = ?';
124	connection.query(sql, [cleaningId], (err, result) => {
125	if (err) {
a.	console.error('Error deleting user: ', err);
b.	res.status(500).send('Internal Server Error');
126	} else {
a.	if (result.affectedRows > 0) {
b.	res.status(200).send('Cleaning deleted successfully');
c.	} else {
d.	res.status(404).send('Cleaning not found');
e.	}
127	}
128	});
129	});

130	app.get('/api/v1/users/:userId', (req, res) => {
131	const userId = req.params.userId;

132	const sql = 'SELECT * FROM user WHERE id = ?';
133	connection.query(sql, [userId], (err, result) => {
134	if (err) {
a.	console.error('Error fetching user details: ', err);
b.	res.status(500).send('Internal Server Error');
135	} else {
a.	if (result.length > 0) {
b.	const userDetails = result[0];
c.	res.status(200).json(userDetails);
d.	} else {
e.	res.status(404).send('User not found');
f.	}
136	}
137	});
138	});

139	app.delete('/api/v1/users/:userId', (req, res) => {
140	const userId = req.params.userId;

141	const sql = 'DELETE FROM user WHERE id = ?';
142	connection.query(sql, [userId], (err, result) => {
143	if (err) {
a.	console.error('Error deleting user: ', err);
b.	res.status(500).send('Internal Server Error');
144	} else {
a.	if (result.affectedRows > 0) {
b.	res.status(200).send('User deleted successfully');
c.	} else {
d.	res.status(404).send('User not found');
e.	}
145	}
146	});
147	});

148	app.post('/api/v1/login', async (req, res) => {
149	const {login, password} = req.body;

150	try {
151	const user = await userManager.login(login, password, connection);

152	if (user) {
a.	res.status(200).json(user);
153	} else {
a.	res.status(401).send('Authentication failed');
154	}
155	} catch (error) {
156	console.error('Error during login: ', error);
157	res.status(500).send('Internal Server Error');
158	}
159	});

160	app.post('/api/v1/users', async (req, res) => {
161	const {login, first_name, phone_number, password, is_admin} = req.body;

162	try {
163	const hashedPassword = await bcrypt.hash(password, 10);

164	const sql = 'INSERT INTO user (login, first_name, phone_number, password, is_admin) VALUES (?, ?, ?, ?, ?)';
165	const values = [login, first_name, phone_number, password, is_admin];

166	connection.query(sql, values, (err, result) => {
a.	if (err) {
b.	console.error('Error inserting data into the database: ', err);
c.	} else {
d.	console.log('Data inserted successfully');
e.	}
167	});
168	} catch (e) {
169	console.error('Error hashing password: ', e);
170	}

171	res.status(200).send('User added successfully');
172	});

173	app.post('/api/v1/register', async (req, res) => {
174	const {login, firstName, phone, password} = req.body;

175	await userManager.registerUser(login, firstName, phone, password, connection);

176	res.sendStatus(200);
177	});

178	app.listen(PORT, '', null, () => console.log(`Server started on port ${PORT}`));



 
ДОДАТОК В
Код клієнтської частини


	Код App.tsx та сумісних файлів
1	import React, {useEffect, useState} from 'react';
2	import {BrowserRouter as Router, Route, Routes} from 'react-router-dom';
3	import './App.scss';
4	import {LanguageProvider, useLanguage} from './LanguageContext';
5	import {TypeUser} from "./types/TypeUser";
6	import Home from "./pages/Home/Home";
7	import 'bootstrap/dist/css/bootstrap.min.css';
8	import Users from "./pages/Admin/Users/Users";
9	import Materials from "./pages/Admin/Materials/Materials";
10	import Services from "./pages/Admin/Services/Services";
11	import Cleaning from "./pages/Admin/Cleaning/Cleaning";
12	
13	const AppContent = () => {
14	  const {translate, setLanguage, language} = useLanguage();
15	  const [showLoginForm, setShowLoginForm] = useState<boolean>(false);
16	  const [user, setUser] = useState<TypeUser>(() => {
17	    const savedUser = sessionStorage.getItem('user');
18	    return savedUser ? JSON.parse(savedUser) : null;
19	  });
20	
21	  return (
22	    <Router>
23	      <Routes>
24	        <Route path={'/'}
25	               element={<Home user={user} setShowLoginForm={setShowLoginForm} showLoginForm={showLoginForm}
26	                              setUser={setUser}/>}/>
27	        <Route path={'/admin/users'} element={<Users user={user} setShowLoginForm={setShowLoginForm} />} />
28	        <Route path={'/admin/services'} element={<Services user={user} setShowLoginForm={setShowLoginForm} />} />
29	        <Route path={'/admin/cleaning'} element={<Cleaning user={user} setShowLoginForm={setShowLoginForm} />} />
30	        <Route path={'/admin/materials'} element={<Materials user={user} setShowLoginForm={setShowLoginForm} />} />
31	      </Routes>
32	    </Router>
33	  );
34	};
35	
36	function App() {
37	  return (
38	    <LanguageProvider>
39	      <AppContent/>
40	    </LanguageProvider>
41	  );
42	}
43	
44	export default App;
45	import {createContext, useState, useContext} from 'react';
46	import translations from './translations';
47	
48	const LanguageContext = createContext({
49	  language: 'en',
50	  setLanguage: (lang: string) => {
51	  },
52	  translate: (key: string) => key,
53	});
54	
55	export const LanguageProvider = ({children}: any) => {
56	  const [language, setLanguage] = useState('en');
57	
58	  const translate = (key: string) => {
59	    // @ts-ignore
60	    return translations[language][key] || key;
61	  };
62	
63	  return (
64	    <LanguageContext.Provider value={{language, setLanguage, translate}}>
65	      {children}
66	    </LanguageContext.Provider>
67	  );
68	};
69	
70	export const useLanguage = () => useContext(LanguageContext);
71	const translations = {
72	  en: {
73	    login: "Login",
74	    Welcome: "Welcome",
75	    Users: "Users",
76	    Services: "Services",
77	    Cleaning: "Cleaning",
78	    Materials: "Materials",
79	    AdminPanel: "Admin Panel",
80	    BookCleaning: "Book Cleaning",
81	    Close: "Close",
82	    SaveChanges: "Save Changes",
83	    Description: "Description",
84	    SelectService: "Select a service",
85	    Price: "Price",
86	    AddUser: "Add User",
87	    Delete: "Delete",
88	    LoginUser: "User login",
89	    FirstName: "First Name",
90	    PhoneNumber: "Phone Number",
91	    Password: "Password",
92	    AddServices: "Add Services",
93	    ServiceName: "Service Name",
94	    ServiceDescription: "Service Description",
95	    AddMaterials: "Add Materials",
96	    MaterialName: "Material Name",
97	  },
98	  ua: {
99	    login: "Увійти",
100	    Welcome: "Вітаємо",
101	    Users: "Користувачі",
102	    Services: "Послуги",
103	    Cleaning: "Замовлені послуги",
104	    Materials: "Склад",
105	    AdminPanel: "Адмін Панель",
106	    BookCleaning: "Замовити послугу",
107	    Close: "Закрити",
108	    SaveChanges: "Зберегти",
109	    Description: "Опис",
110	    SelectService: "Оберіть послугу",
111	    Price: "Ціна",
112	    AddUser: "Додати користувача",
113	    Delete: "Видалити",
114	    LoginUser: "Логін користувача",
115	    FirstName: "Ім'я",
116	    PhoneNumber: "Номер телефону",
117	    Password: "Пароль",
118	    AddServices: "Додати послугу",
119	    ServiceName: "Назва послуги",
120	    ServiceDescription: "Опис послуги",
121	    AddMaterials: "Додати матеріал",
122	    MaterialName: "Ім'я матеріалу",
123	  }
124	};
125	
126	export default translations;
127	class User {
128	  private _id: number;
129	  private _login: string;
130	  private _phone: string;
131	  private _firstName: string;
132	  private _isAdmin: boolean;
133	
134	  constructor(id: number, login: string, firstName: string, phone: string, isAdmin: boolean) {
135	    this._id = id;
136	    this._login = login;
137	    this._firstName = firstName;
138	    this._phone = phone;
139	    this._isAdmin = isAdmin;
140	  }
141	
142	  get id(): number {
143	    return this._id;
144	  }
145	
146	  set id(id: number) {
147	    this._id = id;
148	  }
149	
150	  get login(): string {
151	    return this._login;
152	  }
153	
154	  set login(newLogin: string) {
155	    this._login = newLogin;
156	  }
157	
158	  get phone(): string {
159	    return this._phone;
160	  }
161	
162	  set phone(newPhone: string) {
163	    this._phone = newPhone;
164	  }
165	
166	  get firstName(): string {
167	    return this._firstName;
168	  }
169	
170	  set firstName(newFirstName: string) {
171	    this._firstName = newFirstName;
172	  }
173	
174	  get isAdmin(): boolean {
175	    return this._isAdmin;
176	  }
177	
178	  set isAdmin(value: boolean) {
179	    this._isAdmin = value;
180	  }
181	}
182	
183	export default User;
184	import React, {ChangeEvent, FC, useEffect, useState} from 'react';
185	import './Home.scss';
186	import LoginForm from "../../UIComponents/LoginForm/LoginForm";
187	import Header from "../../UIComponents/Header/Header";
188	import axios from "axios";
189	import {TypeUser} from "../../types/TypeUser";
190	import Button from "react-bootstrap/Button";
191	import Modal from "react-bootstrap/Modal";
192	import CustomInput from "../../UIComponents/CustomInput/CustomInput";
193	import Form from "react-bootstrap/Form";
194	import {TypeService} from "../../types/TypeService";
195	import jsPDF from 'jspdf';
196	// @ts-ignore
197	import RobotoRegular from '../../fonts/Roboto-Regular.ttf';
198	import {useLanguage} from "../../LanguageContext";
199	
200	type TypeHome = {
201	  user: TypeUser,
202	  showLoginForm: any,
203	  setUser: any,
204	  setShowLoginForm: any,
205	}
206	
207	type TypeNewCleaning = {
208	  date: string;
209	  time: string;
210	  description: string;
211	  user_id: number;
212	  service_id: number;
213	}
214	
215	const Home: FC<TypeHome> = ({user, setShowLoginForm, showLoginForm, setUser}) => {
216	  const {translate, setLanguage, language} = useLanguage();
217	  const [services, setServices] = useState<TypeService[]>([]);
218	  const [showModalForm, setShowModalForm] = useState<boolean>(false);
219	  const [newCleaning, setNewCleaning] = useState<TypeNewCleaning>({
220	    date: '',
221	    time: '',
222	    description: '',
223	    user_id: user?.id ? user?.id : 0,
224	    service_id: 0,
225	  });
226	  const [selectedService, setSelectedService] = useState<number | null>(null);
227	
228	  useEffect(() => {
229	    fetchServicesData();
230	  }, []);
231	
232	  const addNewCleaning = async (data: any) => {
233	    try {
234	      const response = await axios.post('http://localhost:5000/api/v1/cleaning', data);
235	
236	      if (response.status === 200) {
237	        handleClose();
238	        clearForm();
239	      }
240	    } catch (e) {
241	      console.error(e);
242	    }
243	  }
244	
245	  const fetchServicesData = async () => {
246	    try {
247	      const response = await axios.get('http://localhost:5000/api/v1/services');
248	      setServices(response.data);
249	    } catch (error) {
250	      console.error('Error fetching services data: ', error);
251	    }
252	  }
253	
254	  const handleSelectChange = (event: ChangeEvent<HTMLSelectElement>) => {
255	    const selectedId = parseInt(event.target.value);
256	    setSelectedService(selectedId);
257	  };
258	
259	  const handleInputChange = (event: ChangeEvent<HTMLInputElement>) => {
260	    const {name, value} = event.target;
261	    setNewCleaning({...newCleaning, [name]: value});
262	  };
263	
264	  const onClickBookCleaning = () => {
265	    if (!user?.id) {
266	      setShowLoginForm(true);
267	      return
268	    }
269	
270	    setShowModalForm(true);
271	    fetchServicesData();
272	  }
273	
274	  const handleClose = (): void => {
275	    setShowModalForm(false);
276	  }
277	
278	  const clearForm = (): void => {
279	    setNewCleaning({
280	      date: '',
281	      time: '',
282	      description: '',
283	      user_id: user?.id ? user?.id : 0,
284	      service_id: 0,
285	    });
286	  }
287	
288	  const saveCheck = (): void => {
289	    const doc = new jsPDF();
290	    doc.addFont(RobotoRegular, 'Roboto', 'normal');
291	    doc.setFont('Roboto', 'normal');
292	    doc.setFontSize(20);
293	    doc.text("ВІТАЮ, ЦЕ ВАШ ЕЛЕКТРОНИЙ ЧЕК!", 10, 10);
294	    doc.setFontSize(16);
295	    doc.text(`Дата запису: ${newCleaning.date}. Час: ${newCleaning.time}`, 10, 20);
296	    doc.text(`Обрана послуга: ${services.find(service => service.id === selectedService)?.name}`, 10, 30);
297	    doc.text(`Коментар: ${newCleaning.description}`, 10, 40);
298	    doc.text(`Отримувач послуги: ${user?.firstName}`, 10, 50);
299	    doc.setFontSize(20);
300	    doc.text(`До сплати: ${services.find(service => service.id === selectedService)?.price} UAH`, 10, 60);
301	    doc.save("check.pdf");
302	  }
303	
304	  const onSubmitBookCleaningForm = (event: React.MouseEvent<HTMLFormElement, MouseEvent>) => {
305	    event.preventDefault();
306	
307	    const data = {
308	      ...newCleaning,
309	      user_id: user?.id,
310	      service_id: selectedService,
311	    }
312	
313	    saveCheck();
314	    addNewCleaning(data);
315	  }
316	
317	  return (
318	    <div id="Home">
319	      {showLoginForm && (<LoginForm setUser={setUser} setShowLoginForm={setShowLoginForm}/>)}
320	      <Header user={user} setShowLoginForm={setShowLoginForm}/>
321	      <Modal show={showModalForm} onHide={handleClose}>
322	        <Modal.Header>
323	          <Modal.Title>{translate("BookCleaning")}</Modal.Title>
324	        </Modal.Header>
325	        <form onSubmit={onSubmitBookCleaningForm}>
326	          <Modal.Body className="users__modal-body">
327	            <input
328	              type="date"
329	              name="date"
330	              value={newCleaning.date}
331	              onChange={handleInputChange}
332	            />
333	            <input
334	              type="time"
335	              name="time"
336	              value={newCleaning.time}
337	              onChange={handleInputChange}
338	            />
339	            <CustomInput type="text" name="description" maxLength={450}
340	                         isValid={(newCleaning.description.length > 3)} label={translate("Description")}
341	                         setState={setNewCleaning} state={newCleaning.description}/>
342	            <Form.Select value={selectedService ?? ''} onChange={handleSelectChange}>
343	              <option value="" disabled>{translate("SelectService")}</option>
344	              {services.map(service => (
345	                <option key={service.id} value={service.id}>
346	                  {service.name}
347	                </option>
348	              ))}
349	            </Form.Select>
350	            {
351	              selectedService && (
352	                <h4>{translate("Price")}: {services.find(service => service.id === selectedService)?.price} UAH</h4>
353	              )
354	            }
355	          </Modal.Body>
356	          <Modal.Footer>
357	            <Button variant="secondary" onClick={handleClose}>
358	              {translate("Close")}
359	            </Button>
360	            <Button variant="primary" type={"submit"}>
361	              {translate("SaveChanges")}
362	            </Button>
363	          </Modal.Footer>
364	        </form>
365	      </Modal>
366	      <main>
367	        <Button size={"lg"} onClick={() => onClickBookCleaning()} variant="primary">{translate("BookCleaning")}</Button>
368	      </main>
369	    </div>
370	  );
371	};
372	
373	export default Home;
374	import React, {FC, useEffect, useState} from 'react';
375	import './Users.scss';
376	import axios from "axios";
377	import Table from 'react-bootstrap/Table';
378	import Button from 'react-bootstrap/Button';
379	import Modal from 'react-bootstrap/Modal';
380	import CustomInput from "../../../UIComponents/CustomInput/CustomInput";
381	import {TypeUser} from "../../../types/TypeUser";
382	import Header from "../../../UIComponents/Header/Header";
383	import {useLanguage} from "../../../LanguageContext";
384	
385	type Props = {
386	  user: TypeUser,
387	  setShowLoginForm: React.Dispatch<React.SetStateAction<boolean>>,
388	}
389	
390	type userProps = {
391	  id: number;
392	  login: string;
393	  phone_number: string;
394	  first_name: string;
395	  is_admin: boolean;
396	}
397	
398	type newUserProps = {
399	  login: string;
400	  password: string;
401	  phone_number: string;
402	  first_name: string;
403	  is_admin: any;
404	};
405	
406	const Users: FC<Props> = ({user, setShowLoginForm}) => {
407	  const {translate, setLanguage, language} = useLanguage();
408	  const [usersArray, setUsersArray] = useState<userProps[]>([]);
409	  const [showModalForm, setShowModalForm] = useState<boolean>(false);
410	  const [newUser, setNewUser] = useState<newUserProps>({
411	    login: '',
412	    password: '',
413	    phone_number: '',
414	    first_name: '',
415	    is_admin: 0,
416	  });
417	
418	  const fetchUsersArrayData = async () => {
419	    try {
420	      const response = await axios.get('http://localhost:5000/api/v1/users');
421	      setUsersArray(response.data);
422	    } catch (error) {
423	      console.error('Error fetching users data: ', error);
424	    }
425	  };
426	
427	  useEffect(() => {
428	    fetchUsersArrayData();
429	  }, []);
430	
431	  const onClickDeleteUser = async (userId: number) => {
432	    try {
433	      const response = await axios.delete(`http://localhost:5000/api/v1/users/${userId}`);
434	      fetchUsersArrayData();
435	    } catch (error) {
436	      console.error('Error deleting user data: ', error);
437	    }
438	  }
439	
440	  const onClickAddUser = () => {
441	    setShowModalForm(true);
442	  }
443	
444	  const addNewUser = async (user: newUserProps) => {
445	    try {
446	      const response = await axios.post('http://localhost:5000/api/v1/users', user);
447	
448	      if (response.status === 200) {
449	        alert('Successful');
450	        fetchUsersArrayData();
451	        handleClose();
452	      }
453	    } catch (e) {
454	      console.error(e);
455	    }
456	  }
457	
458	  const onSubmitAddUserForm = (event: React.MouseEvent<HTMLFormElement, MouseEvent>): void => {
459	    event.preventDefault();
460	    addNewUser(newUser);
461	  }
462	
463	  const handleClose = () => {
464	    setShowModalForm(false)
465	  }
466	
467	  return (
468	    <div id="Users">
469	      <Header user={user} setShowLoginForm={setShowLoginForm}/>
470	      <Modal show={showModalForm} onHide={handleClose}>
471	        <Modal.Header>
472	          <Modal.Title>{translate("AddUser")}</Modal.Title>
473	        </Modal.Header>
474	        <form onSubmit={onSubmitAddUserForm}>
475	          <Modal.Body className="users__modal-body">
476	            <CustomInput customClassName="user-input" type="text" name="login"
477	                         isValid={(newUser.login.length > 3)} label={translate("LoginUser")}
478	                         setState={setNewUser} state={newUser.login}/>
479	            <CustomInput customClassName="user-input" type="text" name="first_name"
480	                         isValid={(newUser.first_name.length > 3)} label={translate("FirstName")}
481	                         setState={setNewUser} state={newUser.first_name}/>
482	            <CustomInput customClassName="user-input" type="text" name="phone_number"
483	                         isValid={(newUser.phone_number.length > 5)} label={translate("PhoneNumber")}
484	                         setState={setNewUser} state={newUser.phone_number}/>
485	            <CustomInput customClassName="user-input" type="password" name="password"
486	                         isValid={(newUser.password.length > 3)} label={translate("Password")}
487	                         setState={setNewUser} state={newUser.password}/>
488	            <label className="checkbox-container">
489	              <input
490	                type="checkbox"
491	                checked={newUser.is_admin}
492	                onChange={(event: React.ChangeEvent<HTMLInputElement>): void => {
493	                  setNewUser({
494	                    ...newUser,
495	                    is_admin: event.target.checked,
496	                  });
497	                }}
498	              />
499	              <p>Is admin? </p>
500	            </label>
501	          </Modal.Body>
502	          <Modal.Footer>
503	            <Button variant="secondary" onClick={handleClose}>
504	              {translate("Close")}
505	            </Button>
506	            <Button variant="primary" type={"submit"}>
507	              {translate("SaveChanges")}
508	            </Button>
509	          </Modal.Footer>
510	        </form>
511	      </Modal>
512	      <div className="users">
513	        <h2>{translate("Users")}</h2>
514	        <Button onClick={() => onClickAddUser()} variant="primary">{translate("AddUser")}</Button>
515	        <Table striped bordered hover>
516	          <thead>
517	          <tr>
518	            <th>id</th>
519	            <th>login</th>
520	            <th>phone number</th>
521	            <th>first name</th>
522	            <th>is admin?</th>
523	          </tr>
524	          </thead>
525	          <tbody>
526	          {
527	            usersArray.length > 0 && usersArray.map((user: userProps, index: number) => (
528	              <tr className="user-table__item" key={index}>
529	                <td>{user?.id}</td>
530	                <td>{user?.login}</td>
531	                <td>{user?.phone_number}</td>
532	                <td>{user?.first_name}</td>
533	                <td>{user?.is_admin}</td>
534	                <td>
535	                  <Button onClick={() => onClickDeleteUser(user.id)} variant="danger">{translate("Delete")}</Button>
536	                </td>
537	              </tr>
538	            ))
539	          }
540	          </tbody>
541	        </Table>
542	      </div>
543	    </div>
544	  );
545	};
546	
547	export default Users;
548	import React, {ChangeEvent, FC, useEffect, useState} from 'react';
549	import './Materials.scss'
550	import {TypeUser} from "../../../types/TypeUser";
551	import Header from "../../../UIComponents/Header/Header";
552	import Button from "react-bootstrap/Button";
553	import Modal from "react-bootstrap/Modal";
554	import CustomInput from "../../../UIComponents/CustomInput/CustomInput";
555	import Table from "react-bootstrap/Table";
556	import axios from "axios";
557	import {TypeService} from "../../../types/TypeService";
558	import Form from 'react-bootstrap/Form';
559	import {useLanguage} from "../../../LanguageContext";
560	
561	type MaterialsProps = {
562	  user: TypeUser,
563	  setShowLoginForm: React.Dispatch<React.SetStateAction<boolean>>,
564	}
565	
566	type TypeMaterial = {
567	  id: number;
568	  name: string;
569	  quantity: number;
570	  service_id: number;
571	}
572	
573	type TypeNewMaterial = {
574	  name: string;
575	  quantity: number;
576	}
577	
578	const Materials: FC<MaterialsProps> = ({user, setShowLoginForm}) => {
579	  const {translate, setLanguage, language} = useLanguage();
580	  const [showModalForm, setShowModalForm] = useState<boolean>(false);
581	  const [materials, setMaterials] = useState<TypeMaterial[]>([]);
582	  const [services, setServices] = useState<TypeService[]>([]);
583	  const [newMaterial, setNewMaterial] = useState<TypeNewMaterial>({
584	    name: '',
585	    quantity: 0,
586	  });
587	  const [selectedService, setSelectedService] = useState<number | null>(null);
588	
589	  useEffect(() => {
590	    fetchMaterialsData();
591	    fetchServicesData();
592	  }, []);
593	
594	  const handleSelectChange = (event: ChangeEvent<HTMLSelectElement>) => {
595	    const selectedId = parseInt(event.target.value);
596	    setSelectedService(selectedId);
597	  };
598	
599	  const fetchMaterialsData = async () => {
600	    try {
601	      const response = await axios.get('http://localhost:5000/api/v1/materials');
602	      setMaterials(response.data);
603	    } catch (error) {
604	      console.error('Error fetching materials data: ', error);
605	    }
606	  }
607	
608	  const handleClose = () => {
609	    setShowModalForm(false)
610	  }
611	
612	  const fetchServicesData = async () => {
613	    try {
614	      const response = await axios.get('http://localhost:5000/api/v1/services');
615	      setServices(response.data);
616	    } catch (error) {
617	      console.error('Error fetching services data: ', error);
618	    }
619	  }
620	
621	  const onClickAddMaterials = async () => {
622	    setShowModalForm(true);
623	    await fetchServicesData();
624	  }
625	
626	  const onClickDeleteMaterial = async (id: number) => {
627	    try {
628	      const response = await axios.delete(`http://localhost:5000/api/v1/materials/${id}`);
629	      fetchMaterialsData();
630	    } catch (error) {
631	      console.error('Error deleting materials data: ', error);
632	    }
633	  }
634	
635	  const addNewMaterial = async (newMaterial: TypeNewMaterial) => {
636	    try {
637	      const data = {...newMaterial, service_id: selectedService}
638	      const response = await axios.post('http://localhost:5000/api/v1/materials', data);
639	
640	      if (response.status === 200) {
641	        alert('Successful');
642	        fetchMaterialsData();
643	        handleClose();
644	      }
645	    } catch (e) {
646	      console.error(e);
647	    }
648	  }
649	
650	  const onSubmitMaterialForm = (event: React.MouseEvent<HTMLFormElement, MouseEvent>): void => {
651	    event.preventDefault();
652	
653	    addNewMaterial(newMaterial);
654	  }
655	
656	  return (
657	    <div id="Materials">
658	      <Header user={user} setShowLoginForm={setShowLoginForm}/>
659	      <Modal show={showModalForm} onHide={handleClose}>
660	        <Modal.Header>
661	          <Modal.Title>{translate("AddMaterials")}</Modal.Title>
662	        </Modal.Header>
663	        <form onSubmit={onSubmitMaterialForm}>
664	          <Modal.Body className="users__modal-body">
665	            <CustomInput type="text" name="name" maxLength={45}
666	                         isValid={(newMaterial.name.length > 3)} label={translate("MaterialName")}
667	                         setState={setNewMaterial} state={newMaterial.name}/>
668	            <CustomInput type="number" name="quantity"
669	                         isValid={newMaterial.quantity > 0} label={''}
670	                         setState={setNewMaterial} state={newMaterial.quantity}/>
671	            <Form.Select value={selectedService ?? ''} onChange={handleSelectChange}>
672	              <option value="" disabled>{translate("SelectService")}</option>
673	              {services.map(service => (
674	                <option key={service.id} value={service.id}>
675	                  {service.name}
676	                </option>
677	              ))}
678	            </Form.Select>
679	          </Modal.Body>
680	          <Modal.Footer>
681	            <Button variant="secondary" onClick={handleClose}>
682	              {translate("Close")}
683	            </Button>
684	            <Button variant="primary" type={"submit"}>
685	              {translate("SaveChanges")}
686	            </Button>
687	          </Modal.Footer>
688	        </form>
689	      </Modal>
690	      <div className="materials">
691	        <h2>{translate("Materials")}</h2>
692	        <Button onClick={() => onClickAddMaterials()} variant="primary">{translate("AddMaterials")}</Button>
693	        <Table striped bordered hover>
694	          <thead>
695	          <tr>
696	            <th>id</th>
697	            <th>material</th>
698	            <th>quantity</th>
699	            <th>service name</th>
700	          </tr>
701	          </thead>
702	          <tbody>
703	          {
704	            materials.length > 0 && materials.map((material: TypeMaterial, index: number) => (
705	              <tr className="user-table__item" key={index}>
706	                <td>{material.id}</td>
707	                <td>{material.name}</td>
708	                <td>{material.quantity}</td>
709	                <td>{services.find(service => service.id === material.service_id)?.name}</td>
710	                <td>
711	                  <Button onClick={() => onClickDeleteMaterial(material.id)} variant="danger">{translate("Delete")}</Button>
712	                </td>
713	              </tr>
714	            ))
715	          }
716	          </tbody>
717	        </Table>
718	      </div>
719	    </div>
720	  );
721	};
722	
723	export default Materials;
724	import React, {FC, useEffect, useState} from 'react';
725	import './Services.scss';
726	import {TypeUser} from "../../../types/TypeUser";
727	import Header from "../../../UIComponents/Header/Header";
728	import Button from "react-bootstrap/Button";
729	import Table from "react-bootstrap/Table";
730	import Modal from "react-bootstrap/Modal";
731	import CustomInput from "../../../UIComponents/CustomInput/CustomInput";
732	import axios from "axios";
733	import {TypeService} from "../../../types/TypeService";
734	import {useLanguage} from "../../../LanguageContext";
735	
736	type ServicesProps = {
737	  user: TypeUser,
738	  setShowLoginForm: React.Dispatch<React.SetStateAction<boolean>>,
739	}
740	
741	type TypeNewService = {
742	  name: string,
743	  description: string,
744	  price: number,
745	}
746	
747	const Services: FC<ServicesProps> = ({user, setShowLoginForm}) => {
748	  const {translate, setLanguage, language} = useLanguage();
749	  const [services, setServices] = useState<TypeService[]>([]);
750	  const [showModalForm, setShowModalForm] = useState<boolean>(false);
751	  const [newService, setNewService] = useState<TypeNewService>({
752	    name: '',
753	    description: '',
754	    price: 0,
755	  });
756	
757	  useEffect(() => {
758	    fetchServicesData();
759	  }, []);
760	
761	  const clearForm = (): void => {
762	    setNewService({
763	      name: '',
764	      description: '',
765	      price: 0,
766	    });
767	  }
768	
769	  const fetchServicesData = async () => {
770	    try {
771	      const response = await axios.get('http://localhost:5000/api/v1/services');
772	      setServices(response.data);
773	    } catch (error) {
774	      console.error('Error fetching services data: ', error);
775	    }
776	  }
777	
778	  const onClickDeleteService = async (serviceId: number) => {
779	    try {
780	      const response = await axios.delete(`http://localhost:5000/api/v1/services/${serviceId}`);
781	      fetchServicesData();
782	    } catch (error) {
783	      console.error('Error deleting service data: ', error);
784	    }
785	  }
786	
787	  const onClickAddMaterial = (): void => {
788	    setShowModalForm(true);
789	  }
790	
791	  const handleClose = (): void => {
792	    setShowModalForm(false);
793	  }
794	
795	  const addNewService = async (newService: TypeNewService) => {
796	    try {
797	      const response = await axios.post('http://localhost:5000/api/v1/services', newService);
798	
799	      if (response.status === 200) {
800	        alert('Successful');
801	        fetchServicesData();
802	        handleClose();
803	      }
804	    } catch (e) {
805	      console.error(e);
806	    }
807	  }
808	
809	  const onSubmitServiceForm = (event: React.MouseEvent<HTMLFormElement, MouseEvent>): void => {
810	    event.preventDefault();
811	
812	    addNewService(newService);
813	    clearForm();
814	  }
815	
816	  return (
817	    <div id="Services">
818	      <Header user={user} setShowLoginForm={setShowLoginForm}/>
819	      <Modal show={showModalForm} onHide={handleClose}>
820	        <Modal.Header>
821	          <Modal.Title>{translate("AddServices")}</Modal.Title>
822	        </Modal.Header>
823	        <form onSubmit={onSubmitServiceForm}>
824	          <Modal.Body className="users__modal-body">
825	            <CustomInput type="text" name="name" maxLength={45}
826	                         isValid={(newService.name.length > 3)} label={translate("ServiceName")}
827	                         setState={setNewService} state={newService.name}/>
828	            <CustomInput type="text" name="description" maxLength={250}
829	                         isValid={(newService.description.length > 3)} label={translate("ServiceDescription")}
830	                         setState={setNewService} state={newService.description}/>
831	            <CustomInput type="number" name="price"
832	                         isValid={newService.price > 0} label={''}
833	                         setState={setNewService} state={newService.price}/>
834	          </Modal.Body>
835	          <Modal.Footer>
836	            <Button variant="secondary" onClick={handleClose}>
837	              {translate("Close")}
838	            </Button>
839	            <Button variant="primary" type={"submit"}>
840	              {translate("SaveChanges")}
841	            </Button>
842	          </Modal.Footer>
843	        </form>
844	      </Modal>
845	      <div className="services">
846	        <h2>{translate("Services")}</h2>
847	        <Button onClick={() => onClickAddMaterial()} variant="primary">{translate("AddServices")}</Button>
848	        <Table striped bordered hover>
849	          <thead>
850	          <tr>
851	            <th>id</th>
852	            <th>name</th>
853	            <th>description</th>
854	            <th>price</th>
855	          </tr>
856	          </thead>
857	          <tbody>
858	          {
859	            services.length > 0 && services.map((service: TypeService, index: number) => (
860	              <tr className="user-table__item" key={index}>
861	                <td>{service.id}</td>
862	                <td>{service.name}</td>
863	                <td>{service.description}</td>
864	                <td>{service.price}</td>
865	                <td>
866	                  <Button onClick={() => onClickDeleteService(service.id)} variant="danger">{translate("Delete")}</Button>
867	                </td>
868	              </tr>
869	            ))
870	          }
871	          </tbody>
872	        </Table>
873	      </div>
874	    </div>
875	  );
876	};
877	
878	export default Services;
879	import React, {FC, useEffect, useState} from 'react';
880	import './Cleaning.scss';
881	import Header from "../../../UIComponents/Header/Header";
882	import {TypeUser} from "../../../types/TypeUser";
883	import {TypeCleaning} from "../../../types/TypeCleaning";
884	import Button from "react-bootstrap/Button";
885	import Table from "react-bootstrap/Table";
886	import axios from "axios";
887	import {TypeService} from "../../../types/TypeService";
888	import {useLanguage} from "../../../LanguageContext";
889	
890	type CleaningProps = {
891	  user: TypeUser,
892	  setShowLoginForm: React.Dispatch<React.SetStateAction<boolean>>,
893	}
894	
895	const Cleaning: FC<CleaningProps> = ({user, setShowLoginForm}) => {
896	  const {translate, setLanguage, language} = useLanguage();
897	  const [cleaning, setCleaning] = useState<TypeCleaning[]>([]);
898	  const [users, setUsers] = useState<any[]>([]);
899	  const [services, setServices] = useState<TypeService[]>([]);
900	
901	  useEffect(() => {
902	    fetchServicesData();
903	    fetchCleaningData();
904	    fetchUserData();
905	  }, []);
906	
907	  const fetchServicesData = async () => {
908	    try {
909	      const response = await axios.get('http://localhost:5000/api/v1/services');
910	      setServices(response.data);
911	    } catch (error) {
912	      console.error('Error fetching services data: ', error);
913	    }
914	  }
915	
916	  const fetchCleaningData = async () => {
917	    try {
918	      const response = await axios.get('http://localhost:5000/api/v1/cleaning');
919	      setCleaning(response.data);
920	    } catch (error) {
921	      console.error('Error fetching cleaning data: ', error);
922	    }
923	  }
924	
925	  const fetchUserData = async () => {
926	    try {
927	      const response = await axios.get('http://localhost:5000/api/v1/users');
928	      setUsers(response.data);
929	    } catch (error) {
930	      console.error('Error fetching users data: ', error);
931	    }
932	  }
933	
934	  const onClickDeleteCleaning = async (cleaningId: number) => {
935	    try {
936	      const response = await axios.delete(`http://localhost:5000/api/v1/cleaning/${cleaningId}`);
937	      fetchCleaningData();
938	    } catch (error) {
939	      console.error('Error deleting cleaning data: ', error);
940	    }
941	  }
942	
943	  return (
944	    <div id="Cleaning">
945	      <Header user={user} setShowLoginForm={setShowLoginForm}/>
946	      <h2>{translate("Cleaning")}</h2>
947	      <Table striped bordered hover>
948	        <thead>
949	        <tr>
950	          <th>id</th>
951	          <th>date</th>
952	          <th>time</th>
953	          <th>description</th>
954	          <th>user name</th>
955	          <th>user phone</th>
956	          <th>service name</th>
957	        </tr>
958	        </thead>
959	        <tbody>
960	        {
961	          cleaning.length > 0 && cleaning.map((cleaning: TypeCleaning, index: number) => (
962	            <tr key={index}>
963	              <td>{cleaning.id}</td>
964	              <td>{cleaning.date}</td>
965	              <td>{cleaning.time}</td>
966	              <td>{cleaning.description}</td>
967	              <td>{users.find(user => user?.id === cleaning.user_id)?.first_name}</td>
968	              <td>{users.find(user => user?.id === cleaning.user_id)?.phone_number}</td>
969	              <td>{services.find(service => service?.id === cleaning.service_id)?.name}</td>
970	              <td>
971	                <Button onClick={() => onClickDeleteCleaning(cleaning.id)} variant="danger">{translate("Delete")}</Button>
972	              </td>
973	            </tr>
974	          ))
975	        }
976	        </tbody>
977	      </Table>
978	    </div>
979	  );
980	};
981	
982	export default Cleaning;
